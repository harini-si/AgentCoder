[
  {
    "game": "catcher",
    "prompt": "Create a catcher character, represented as a rectangle, positioned at the bottom and the middle of the screen.Allow the player to control the catcher's horizontal movement using the left and right arrow keys on the keyboard.Periodically spawn balls with random x-coordinates at the top of the screen. The ball should be visually distinct and easily recognizable. There should always be at least one ball on the screen.Make the ball move downwards at a steady pace towards the catcher. The speed can be constant or increase gradually as the game progresses.Detect collisions between the catcher and the ball. When the catcher catches a ball, increment the player's score and display this score in the top-left corner of the screen.Give the player a 3 lives. Each time a ball is missed by the catcher and reaches the bottom of the screen, decrease the player's life count by one.End the game when the player's lives reach zero. Display a 'Game Over!' message and temporarily halt gameplay but dont terminate the game.Provide an option for the player to click the screen to restart the game after the 'Game Over' screen is displayed.Continuously generate new balls after each catch or miss, ensuring endless gameplay. Optionally, increase the game's difficulty gradually by speeding up the ball's fall or reducing the size of the catcher as the player's score increases.",
    "backbone": "\nimport pygame\nimport sys\nimport random\n\n# initialize constants\nSCREEN_WIDTH = 1000\nSCREEN_HEIGHT = 1000\n\n\nclass Catcher(pygame.sprite.Sprite):\n    def __init__(self, x):\n        \"\"\"\n        Initialize the catcher\n        self.rect should be a pygame.Rect object with the initial position of the catcher\n        \"\"\"\n        super().__init__()\n\n\nclass Ball(pygame.sprite.Sprite):\n    def __init__(self, x):\n        \"\"\"\n        initialize the ball\n        x should be the initial x-coordinate of the catcher\n        self.rect should be a pygame.Rect object with the initial position of the catcher\n        \"\"\"\n        super().__init__()\n\n\n\nclass Game:\n    def __init__(self):\n        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))\n        self.clock = pygame.time.Clock()\n        self.reset_game()\n\n    def reset_game(self):\n        \"\"\"\n        Initialize / reset the game\n        self.game_over is a boolean representing whether the game is over\n        self.lives represents the number of lives the player has\n        self.score keeps track of the player's score\n        self.catch is an instance of the Catcher class\n        self.balls is a Sprite Group of all balls (of the class Ball), it should never be empty\n        \"\"\"\n        self.game_over = False\n        self.lives = 3\n        self.score = 0\n        self.catcher = Catcher(...)\n        ...\n\n\n    def run(self, event):\n        \"\"\" \n        please implement the main game loop here\n        \"\"\"\n        \n\n\nif __name__ == \"__main__\":\n    game = Game()\n    pygame.init()\n    running = True\n    while running:\n        event = pygame.event.poll()\n        running = game.run(event)\n    pygame.quit()\n"
  },
  {
    "game": "flappybird",
    "prompt": "Create a bird character, visually represented as a simple rectangle, that remains static in the horizontal axis but can move up and down with arrow keys within the game window.Introduce gravity, causing the bird to continuously fall unless counteracted by player input.Allow the bird to 'jump' or move upwards in response to a player's mouse click or key press, temporarily overcoming gravity.Periodically spawn pairs of vertical pipes moving from right to left across the screen. Each pair should have a gap for the bird to pass through, and their heights should vary randomly.Implement collision detection so that the game ends if the bird touches the pipes or the bottom of the game window.When the game ends, display a 'Game Over!' messagea and stop all the motion of the game.Implement a scoring system, where the player earns points each time the bird successfully passes between a pair of pipes without colliding.Show the current score in the top-left corner of the screen during gameplay.Ensure the game has no predefined end and that new pipes continue to generate, maintaining consistent difficulty as the game progresses.",
    "backbone": "\nimport pygame\nimport sys\nimport random\n\n# initialize constants\nSCREEN_WIDTH = 1000\nSCREEN_HEIGHT = 1000\nPIPE_WIDTH = 80\n\n\nclass Bird(pygame.sprite.Sprite):\n    def __init__(self, x, y):\n        \"\"\"\n        self.rect is the pygame.Rect rectangle representing the bird\n        x and y are the initial x and y positions of the bird\n        \"\"\"\n        super().__init__()\n        self.rect = ...\n\n    def update(self):\n        \"\"\"\n        This will be called every game loop\n        \"\"\"\n\n\nclass Pipe(pygame.sprite.Sprite):\n    def __init__(self, x):\n        \"\"\"\n        x is the initial x position of this instance on screen\n        rect is the pygame.Rect instance representing the pipe\n        passed is a boolean representing whether the bird has passed this pipe\n        \"\"\"\n        super().__init__()\n        self.x = x\n        self.rect = ...\n\n    def update(self):\n        \"\"\"\n        This will be called every game loop\n        \"\"\"\n\n\nclass Game(pygame.sprite.Sprite):\n    def __init__(self):\n        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))\n        self.clock = pygame.time.Clock()\n        self.reset_game()\n        \n    def reset_game(self):\n        \"\"\"\n        Initialize / reset the game\n        self.game_over is a boolean representing whether the game is over\n        self.score keeps track of the player's score\n        self.bird is the Bird instance\n        self.pipes is a list of Pipe instances (it should not be empty)\n        \"\"\"\n        self.game_over = False\n        self.bird = Bird(...)\n        self.pipes = []\n        self.pipes.append(Pipe(...))\n        ...\n        \n    def run(self, event):\n        \"\"\" \n        please implement the game loop here, given the pygame event\n        \"\"\"\n\nif __name__ == \"__main__\":\n    game = Game()\n    pygame.init()\n    running = True\n    while running:\n        event = pygame.event.poll()\n        running = game.run(event)\n    pygame.quit()\n"
  },
  {
    "game": "snake",
    "prompt": "Create a snake character represented as a series of connected pixels or blocks. Initially, the snake should be a single block that moves in a specific direction within the game window.Allow the player to control the snake's movement using arrow keys. The snake should be able to turn left or right, but it should not be able to move directly backward.Introduce a grid-based system for the game window, and ensure that the snake moves one grid unit at a time. The movement should be continuous in the current direction until the player provides new input.Implement a basic food system where a food item appears randomly on the screen.When the snake consumes the food by moving over or colliding with it, the snake's length increases, and the player earns points.Implement collision detection to check if the snake collides with itself or hits the game window boundaries. When a collision occurs, end the game and display a 'Game Over!' message.Incorporate a scoring system, displaying the current score on the screen during gameplay. The score should increase each time the snake consumes food.Ensure that the game has no predefined end, allowing the snake to continue growing and the difficulty to increase over time. New food items should appear after the snake consumes one.Provide an option for the player to restart the game after it ends. Display a 'Restart' option on the game over screen to allow the player to play again.",
    "backbone": "\nimport pygame\nimport sys\nimport random\n\n# Define constants for the game\nSCREEN_WIDTH = 1000\nSCREEN_HEIGHT = 1000\n# Define the size of each grid unit / snake's body segment\n# every time the snake moves, it should move by this amount\nGRID_SIZE = 20\n\n\nclass Snake(pygame.sprite.Sprite):\n    def __init__(self):\n        \"\"\"\n        Initialize the snake's body, direction and image.\n        self.body should be a list of tuples representing the snake's body segments (top-left coordinates)\n        self.direction should be one of {\"UP\", \"DOWN\", \"LEFT\", \"RIGHT\"}\n        self.length should be an integer representing the length of the snake\n        self.rect should be a pygame.Rect object with the head position of the snake\n        \"\"\"\n        super().__init__()\n        self.body = [(500, 500)]\n        self.direction = \"UP\"\n\n\nclass Food(pygame.sprite.Sprite):\n    def __init__(self, x, y):\n        \"\"\"\n        Initialize the food's position and image.\n        self.x and self.y should be the top-left coordinate of the food\n        self.rect should be a pygame.Rect object with the initial position of the food\n        \"\"\"\n        super().__init__()\n        self.x = x\n        self.y = y\n        self.rect = ...\n\n\nclass Game:\n    \"\"\"\n    The main class for the Snake game.\n    \"\"\"\n    def __init__(self):\n        \"\"\"\n        Initialize the game and its components.\n        \"\"\"\n        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))\n        self.clock = pygame.time.Clock()\n        self.reset_game()\n\n    def reset_game(self):\n        \"\"\"\n        Reset the game to its initial state.\n        self.game_over is a boolean representing whether the game is over\n        self.snake is a Snake object representing the snake character\n        self.food is a Food object representing the active food item (randomize the food location)\n        \"\"\"\n        self.game_over = False\n        self.snake = Snake()\n        self.food = Food(...)\n\n    def run(self):\n        \"\"\"\n        please implement the main game loop here\n        \"\"\"\n\n\nif __name__ == \"__main__\":\n    game = Game()\n    pygame.init()\n    running = True\n    while running:\n        event = pygame.event.poll()\n        running = game.run(event)\n    pygame.quit()\n"
  },
  {
    "game": "pong",
    "prompt": "Create a paddle character for the human player, represented as a rectangle, positioned on the left side of the screen. Allow the human player to control the paddle's vertical movement using the up and down arrow keys.Implement a paddle character for the CPU opponent, also represented as a rectangle, positioned on the opposite side of the screen.Enable the CPU to control its paddle's vertical movement to autonomously track the ball.Introduce a ball that moves horizontally across the screen. The ball should bounce off the paddles and the top and bottom walls of the game window.Detect collisions between the ball and the paddles. When the ball collides with a paddle, make it bounce off in the opposite direction.Introduce scoring mechanics, where the human player earns a point if the CPU fails to return the ball, and vice versa. Display the current score at the top of the screen.Ensure the game has no predefined end, allowing for continuous play. Display a 'Game Over!' message when one player reaches a score of 5 and provide an option for the player to restart the game after the 'Game Over' screen is displayed.",
    "backbone": "\nimport pygame\nimport sys\n\nWIDTH, HEIGHT = 1000, 1000\nFPS = 60\nBLACK = (0, 0, 0)\nWHITE = (255, 255, 255)\n\n\nclass Ball(pygame.sprite.Sprite):\n    def __init__(self):\n        \"\"\"\n        Initializes the Ball instance.\n        image: Surface representing the ball\n        rect: Rect object representing the ball's position and size\n        speed: A list containing the speed of the ball in x and y directions (e.g. [5, -5])\n        \"\"\"\n        super().__init__()\n        self.image = pygame.Surface((20, 20))\n        self.image.fill(WHITE)\n        self.rect = self.image.get_rect()\n    # complete the implementation\n\n\nclass PaddleHuman(pygame.sprite.Sprite):\n    def __init__(self):\n        \"\"\"\n        Initializes the human-controlled paddle.\n        image: Surface representing the paddle\n        rect: Rect object representing the paddle's position and size\n        speed: Integer representing the paddle's movement speed\n        \"\"\"\n        super().__init__()\n        self.image = pygame.Surface((20, 100))\n        self.image.fill(WHITE)\n        self.rect = self.image.get_rect()\n        self.speed = 10\n        ...\n    # complete the implementation\n\n\nclass PaddleCPU(pygame.sprite.Sprite):\n    def __init__(self, game):\n        \"\"\"\n        Initializes the CPU-controlled paddle.\n        image: Surface representing the paddle\n        rect: Rect object representing the paddle's position and size\n        speed: An integer representing the paddle's movement speed\n        game: Reference to the Game object\n        \"\"\"\n        super().__init__()\n        self.image = pygame.Surface((20, 100))\n        self.image.fill(WHITE)\n    # complete the implementation\n\n\nclass Game:\n    def __init__(self):\n        \"\"\"\n        Initializes the game.\n        screen: Pygame display surface\n        clock: Pygame Clock object for controlling frame rate\n        game_over: Boolean representing whether the game is over\n        all_sprites: Pygame group containing all sprites in the game\n        ball: Ball object\n        paddle_human: Human-controlled paddle object\n        paddle_cpu: CPU-controlled paddle object\n        score_human: An integer representing the human player's score\n        score_cpu: An integer representing the CPU player's score\n        font: Pygame font object for rendering text\n        \"\"\"\n\n        pygame.init()\n        self.screen = pygame.display.set_mode((WIDTH, HEIGHT))\n        self.clock = pygame.time.Clock()\n        self.game_over = False\n        self.ball = Ball()\n        \n        # complete the implementation here\n\n       \n    def run(self, event):\n        \"\"\"\n        Runs the game loop.\n        event: Pygame event object\n        Returns: Boolean indicating whether to continue running the game\n        \"\"\"\n        # complete the implementation\n\n\nif __name__ == \"__main__\":\n    game = Game()\n    pygame.init()\n    running = True\n    while running:\n        event = pygame.event.poll()\n        running = game.run(event)\n    pygame.quit()\n"
  },
  {
    "game": "puckworld",
    "prompt": "Create an agent character, visually represented as a blue circle, positioned on the screen. The agent should be movable in any direction based on user input.Implement a green dot that moves randomly around the screen, serving as the target for the agent to navigate towards.Introduce a red puck, a larger entity that slowly follows the agent's movements on the screen.Allow the player to control the agent's movement using arrow keys or another specified input method.Implement a scoring system that positively rewards the agent proportionally to the closeness between the agent and the green dot, and penalizes the agent for proximity to the red puck.Display the current score in the top-left corner of the screen during gameplay.Ensure the game has no predefined end, allowing for endless gameplay. Upon reaching the green dot, relocate it to a new random position, maintaining the challenge for the player.",
    "backbone": "\nimport pygame\nimport sys\nimport random\nimport math\n\nWIDTH, HEIGHT = 1000, 1000\nFPS = 60\n\nBLACK = (0, 0, 0)\nWHITE = (255, 255, 255)\nBLUE = (0, 0, 255)\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\n\n\nclass Game:\n    def __init__(self):\n        \"\"\"Initialize the game\n        self.screen is the Pygame display surface\n        self.agent: the player's character\n        self.green_dot: the target for the agent\n        self.red_puck: the obstacle for the agent\n        self.score: the player's score\n        \"\"\"\n        pygame.init()\n        self.screen = pygame.display.set_mode((WIDTH, HEIGHT))\n        ...\n\n    def run(self, event):\n        \"\"\"please implement the game loop here, given the pygame event\"\"\"\n        ...\n\n\nclass Agent(pygame.sprite.Sprite):\n    def __init__(self):\n        \"\"\"Initialize the agent\n        velocity: the agent's speed\n        self.image is the Pygame Surface object representing the Agent\n        self.rect is the Pygame Rect object representing the agent's position\n        \"\"\"\n        super().__init__()\n        ...\n    ...\n\n\nclass RedPuck(pygame.sprite.Sprite):\n    \"\"\"Class representing the red puck obstacle\"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the red puck\n        self.image is the Pygame Surface object representing the RedPuck\n        self.rect is the Pygame Rect object representing the RedPuck's position\n        \"\"\"\n        super().__init__()\n        ...\n    ...\n\n\nclass GreenDot(pygame.sprite.Sprite):\n    def __init__(self):\n        \"\"\"\n        Initialize the green dot\n        self.image is the Pygame Surface object representing the GreenDot\n        self.rect is the Pygame Rect object representing the GreenDot's position\n        \"\"\"\n        super().__init__()\n        ...\n    ...\n\n\nif __name__ == \"__main__\":\n    game = Game()\n    running = True\n    while running:\n        event = pygame.event.poll()\n        running = game.run(event)\n    pygame.quit()\n    sys.exit()\n"
  },
  {
    "game": "waterworld",
    "prompt": "Create a character for WaterWorld, visually represented as a blue circle, that can move freely within the game window using arrow keys.Introduce a dynamic environment with equal number of green and red circles.Make the green and red circles move randomly around the screen.Implement a scoring system, where the player earns points for each green circle captured and deduct one for each red circle . Display the current score in the top-left corner of the screen during gameplay.When the blue circle captures a circle, make it respawn in a random location on the screen as either red or green.Ensure the game continues until all green circles have been captured. Once all green circles are captured, display a 'Game Over!' message and stop all motion in the game.Provide an option for the player to restart the game after it ends, creating a loop for continuous gameplay.",
    "backbone": "\nimport pygame\nimport sys\nimport random\n\nWIDTH, HEIGHT = 640, 480\nGRID_SIZE = 20\nGRID_WIDTH = WIDTH // GRID_SIZE\nGRID_HEIGHT = HEIGHT // GRID_SIZE\nFPS = 60\nCIRCLE_RADIUS = 10\n\nBLUE = (0, 0, 255)\nWHITE = (255, 255, 255)\nRED = (255, 0, 0)\nGREEN = (0, 255, 0)\n\n\nclass Game:\n    def __init__(self):\n        \"\"\"\n        Initialize the game window, clock, game_over status, and score.\n        Create sprite groups for all game objects.\n        agent: The player-controlled sprite.\n        circles: A group of all circles in the game.\n        \n        \"\"\"\n        pygame.init()\n        self.screen = pygame.display.set_mode((WIDTH, HEIGHT))\n        pygame.display.set_caption(\"WaterWorld Game\")\n\n        \n\n    def spawn_initial_circles(self):\n        \"\"\"\n        Spawn initial circles on the game grid.\n        \"\"\"\n        \n    def spawn_circle(self, color):\n        \"\"\"\n        Spawn a circle with the given color on the game grid.\n        Ensure no collision with existing sprites.\n        \"\"\"\n        \n\n    def update_circles(self):\n        \"\"\"\n        Update circles based on collisions with the agent.\n        Update score accordingly.\n        \"\"\"\n        \n\n    def reset_game(self):\n        \"\"\"\n        Reset the game state.\n        \"\"\"\n        \n\n    def handle_events(self, event):\n        \"\"\"\n        Handle game events, including quitting and restarting the game.\n        \"\"\"\n        \n\n    def render_game(self):\n        \"\"\"\n        Render the game screen, including sprites and score.\n        Display game over or win messages as needed.\n        \"\"\"\n        \n\n    def show_message(self, message, size=36):\n        \"\"\"\n        Display a message on the screen.\n        \"\"\"\n        \n\n    def run(self, event):\n        \"\"\"\n        Main game loop.\n        \"\"\"\n        pass\n\n\nclass Agent(pygame.sprite.Sprite):\n    def __init__(self):\n        \"\"\"\n        Initialize the agent sprite.\n        \n        \"\"\"\n        super().__init__()\n        self.image = pygame.Surface(\n            (CIRCLE_RADIUS * 2, CIRCLE_RADIUS * 2), pygame.SRCALPHA\n        )\n        pygame.draw.circle(\n            self.image, BLUE, (CIRCLE_RADIUS, CIRCLE_RADIUS), CIRCLE_RADIUS\n        )\n        self.rect = self.image.get_rect()\n        self.rect.topleft = (GRID_WIDTH // 2 * GRID_SIZE, GRID_HEIGHT // 2 * GRID_SIZE)\n\n    def reset(self):\n        \"\"\"\n        Reset the agent's position.\n        \"\"\"\n        self.rect.topleft = (GRID_WIDTH // 2 * GRID_SIZE, GRID_HEIGHT // 2 * GRID_SIZE)\n\n    def move(self, direction):\n        \"\"\"\n        Move the agent in the specified direction.\n        \"\"\"\n       \n\n    def update(self):\n        \"\"\"\n        Update method for the agent (unused in this example).\n        \"\"\"\n        pass\n\n\nclass Circle(pygame.sprite.Sprite):\n    def __init__(self, color):\n        \"\"\"\n        Initialize a circle sprite with a specified color and direction\n        \"\"\"\n        super().__init__()\n        self.color = color\n        self.image = pygame.Surface(\n            (CIRCLE_RADIUS * 2, CIRCLE_RADIUS * 2), pygame.SRCALPHA\n        )\n        \n\n    def reset(self):\n        \"\"\"\n        Reset the circle's position and direction.\n        \"\"\"\n        \n        \n    def update(self):\n        \"\"\"\n        Update the circle's position.\n        \"\"\"\n\n\n    def move_smoothly(self):\n        \"\"\"\n        Move the circle smoothly across the screen.\n        \"\"\"\n\n\nif __name__ == \"__main__\":\n    game = Game()\n    pygame.init()\n    running = True\n    while running:\n        event = pygame.event.poll()\n        running = game.run(event)\n    pygame.quit()\n\n"
  },
  {
    "game": "pixelcopter",
    "prompt": "Create a player character represented as a large white square, resembling a helicopter, that remains fixed horizontally but can ascend and descend vertically within the game window. Introduce gravity mechanics, causing the helicopter to continuously descend unless the player provides input to ascend.Enable the helicopter to ascend when the player presses the space bar or clicks the mouse, allowing it to momentarily counteract gravity and rise upwards.Periodically generate obstacles in the form of vertically arranged walls or structures that form an infinitely generated maze. There should always be at least one obstacle at any point in the game.Implement collision detection to detect when the helicopter collides with obstacles or the boundaries of the game window, triggering the end of the game upon collision.Display a 'Game Over!' message prominently when the game ends due to a collision, halting all movement within the game and prompting the player to restart.Create a scoring system that rewards the player based on how far the helicopter travels through the maze without colliding with obstacles.Show the current score in the top left area of the screen.Ensure the game has no predefined end and that new obstacles continue to generate, maintaining consistent difficulty as the game progresses. Allow the player to start a new game after a collision.",
    "backbone": "\nimport pygame\nimport sys\nimport random\n\nWIDTH, HEIGHT = 1000, 1000\nFPS = 60\n\nBLACK = (0, 0, 0)\nWHITE = (255, 255, 255)\n\nCAVERN_WIDTH = 100  # Width of the gap in the cavern\n\n\nclass Game:\n    def __init__(self):\n        \"\"\"\n        Initialize the game\n        self.screen is the Pygame display surface\n        self.clock is the Pygame Clock\n        self.game_over is a boolean representing whether the game is over\n        self.player is the Pixelcopter instance\n        self.obstacles is a Pygame sprite Group containing Obstacle instances\n        self.all_sprites is a Pygame sprite Group containing all sprites\n        \"\"\"\n        self.screen = ...\n        self.clock = ...\n        self.game_over = False\n        self.player = ...\n        self.obstacles = ...\n        self.all_sprites = ...\n        ...\n\n    def spawn_obstacle(self):\n        \"\"\"\n        Spawn obstacles in the game world\n        \"\"\"\n        ...\n\n    def reset_game(self):\n        \"\"\"\n        Reset the game to its initial state\n        \"\"\"\n        ...\n\n    def run(self, event):\n        \"\"\"\n        Run the game loop\n        event is the current Pygame event\n        Returns False if the game should exit, True otherwise\n        \"\"\"\n        ...\n\n\nclass Pixelcopter(pygame.sprite.Sprite):\n    def __init__(self):\n        \"\"\"\n        Initialize the Pixelcopter\n        self.image is the Pygame Surface representing the Pixelcopter\n        self.rect is the Pygame Rect representing the Pixelcopter's position and size\n        self.velocity is the Pixelcopter's vertical velocity\n        \"\"\"\n        ...\n\n    def update(self):\n        \"\"\"\n        Update the Pixelcopter's position\n        \"\"\"\n        ...\n\n    def jump(self):\n        \"\"\"\n        Make the Pixelcopter jump\n        \"\"\"\n        ...\n\n\nclass Obstacle(pygame.sprite.Sprite):\n    def __init__(self, top=None, bottom=None):\n        \"\"\"\n        Initialize an obstacle\n        top is the top y-coordinate of the obstacle's gap (if applicable)\n        bottom is the bottom y-coordinate of the obstacle's gap (if applicable)\n        self.image is the Pygame Surface representing the obstacle\n        self.rect is the Pygame Rect representing the obstacle's position and size\n        \"\"\"\n        ...\n\n    def update(self):\n        \"\"\"\n        Update the obstacle's position\n        \"\"\"\n        ...\n\n\nif __name__ == \"__main__\":\n    game = Game()\n    pygame.init()\n    running = True\n    while running:\n        event = pygame.event.poll()\n        running = game.run(event)\n    pygame.quit()\n"
  }
]